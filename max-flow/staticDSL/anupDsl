function do_max_flow (Graph g, int source, int sink,int kernel_parameter) {

  propNode<int> label;
  g.attachNodeProperty (label = 0) ;
  source.label = g.num_nodes();
  
  propNode<int> excess;
  g.attachNodeProperty (excess = 0) ;

  container <int> _count ;
  _count.assign (g.num_nodes () + 2, 0) ;
	
	propEdge<int> residual_capacity;
	g.attachEdgeProperty(residual_capacity=g.weights);
	
	int excesstotal=0;
	
	forall (v in g.nodes().filter(v==source)) {
		for(vv in g.neighbors(v)){
			int x=source;
			edge forward_edge = g.get_edge(x, vv) ;
			edge backward_edge = g.get_edge(vv, x) ;

			int d = forward_edge.residual_capacity;
			excesstotal +=d;
			vv.excess += d;

			forward_edge.residual_capacity -= d;

			backward_edge.residual_capacity += d;
		}
  }
	bool flag=true;

	do{
    forall (v in g.nodes().filter(v.excess>0 && v!=source && v!=sink )) {
			int x=kernel_parameter;
      do{
				x =x+ (-1);
				int hh= INT_MAX;
				int lv=-1;
		
				forall(vv in g.neighbors(v)) {
					edge e = g.get_edge (v,vv);
					int xxx=e.residual_capacity;
					if(vv.label<hh && xxx >0){
						lv=vv;
						hh=vv.label;
					}
					
				}
				if(v.label>hh && lv!=-1){
					edge current_edge = g.get_edge (v,lv) ;
					int cec = current_edge.residual_capacity;
                    if (v.excess > 0 && cec > 0) {
                        edge forward_edge = g.get_edge (v, lv) ;
                        edge backward_edge = g.get_edge (lv, v) ;
						int fec = forward_edge.residual_capacity;
						int bec = backward_edge.residual_capacity;
						int d=fec;
						if(v.excess<fec){
							d=v.excess;
						}
						v.excess -= d ;
                        lv.excess += d ;
						
						forward_edge.residual_capacity -= d ;
                        backward_edge.residual_capacity += d ;
                    }
				}
				else if(lv!=-1){
          int currLab = v.label ;
          __count[currLab] += 1 ;
					v.label = hh + 1;
          __count[hh+1] += 1 ;
				}
                
      }while(x>0);

      int gap = __count.getIdx (0) ;
      if (gap > 0) {
        forall (v in g.nodes (). filter (v != sink && v != source && v.label >= gap)) {
          label.setValue (v, g.num_nodes () + 2) ;
        }
      }
    }
		if(source.excess+sink.excess==excesstotal){
			flag=false;
		}
		
    }while(flag);    

}
